{"id": "57adf375-b150-4f19-9f12-d873f64582d8", "file": "cpu-intro.pdf", "page": 1, "start": 0, "end": 800, "text": "4\nThe Abstraction: The Process\nIn this chapter , we discuss one of the most fundamental abstract ions that\nthe OS provides to users: the process. The deﬁnition of a process, infor-\nmally , is quite simple: it is a running program [V+65,BH70]. The program\nitself is a lifeless thing: it just sits there on the disk, a bun ch of instructions\n(and maybe some static data), waiting to spring into action. It is the oper-\nating system that takes these bytes and gets them running, tr ansforming\nthe program into something useful.\nIt turns out that one often wants to run more than one program at\nonce; for example, consider your desktop or laptop where you might lik e\nto run a web browser , mail program, a game, a music player , and so forth.\nIn fact, a typical system may be seemingly running tens or e"}
{"id": "9bac20fd-a2ad-458e-9f87-1410c1f763d0", "file": "cpu-intro.pdf", "page": 1, "start": 650, "end": 1450, "text": "u might lik e\nto run a web browser , mail program, a game, a music player , and so forth.\nIn fact, a typical system may be seemingly running tens or even hundreds\nof processes at the same time. Doing so makes the system easy to us e, as\none never need be concerned with whether a CPU is available; one s imply\nruns programs. Hence our challenge:\nTH E CR U X O F T H E PR O B L E M :\nHO W TO PR O V I D E TH E IL L U S I O N OF MA N Y CPU S?\nAlthough there are only a few physical CPUs available, how can th e\nOS provide the illusion of a nearly-endless supply of said CPUs?\nThe OS creates this illusion by virtualizing the CPU. By running one\nprocess, then stopping it and running another , and so forth, the O S can\npromote the illusion that many virtual CPUs exist when in fact th ere is\nonly one p"}
{"id": "7c0d71a1-f04d-4bbf-b1dc-15710bf7094b", "file": "cpu-intro.pdf", "page": 1, "start": 1300, "end": 2045, "text": ", then stopping it and running another , and so forth, the O S can\npromote the illusion that many virtual CPUs exist when in fact th ere is\nonly one physical CPU (or a few). This basic technique, known as time\nsharing of the CPU, allows users to run as many concurrent processes as\nthey would like; the potential cost is performance, as each will r un more\nslowly if the CPU(s) must be shared.\nT o implement virtualization of the CPU, and to implement it wel l, the\nOS will need both some low-level machinery and some high-level in -\ntelligence. W e call the low-level machinery mechanisms; mechanisms\nare low-level methods or protocols that implement a needed piece of\nfunctionality . For example, we’ll learn later how to implement a context\n1"}
{"id": "fd4106ac-a5ea-4fff-aabc-98068555a542", "file": "cpu-intro.pdf", "page": 2, "start": 0, "end": 800, "text": "2 T H E AB S T R A C T I O N : T H E PR O C E S S\nTI P : U S E TI M E SH A R I N G (A N D SPA C E SH A R I N G )\nTime sharing is a basic technique used by an OS to share a resource. By\nallowing the resource to be used for a little while by one entity , a nd then\na little while by another , and so forth, the resource in question ( e.g., the\nCPU, or a network link) can be shared by many . The counterpart of ti me\nsharing is space sharing , where a resource is divided (in space) among\nthose who wish to use it. For example, disk space is naturally a s pace-\nshared resource; once a block is assigned to a ﬁle, it is normally n ot as-\nsigned to another ﬁle until the user deletes the original ﬁle.\nswitch, which gives the OS the ability to stop running one program and\nstart running another on a giv"}
{"id": "51d202f5-14b5-4765-9fb9-ff65a31f55dc", "file": "cpu-intro.pdf", "page": 2, "start": 650, "end": 1450, "text": "her ﬁle until the user deletes the original ﬁle.\nswitch, which gives the OS the ability to stop running one program and\nstart running another on a given CPU; this time-sharing mechanism is\nemployed by all modern OSes.\nOn top of these mechanisms resides some of the intelligence in the\nOS, in the form of policies. Policies are algorithms for making some\nkind of decision within the OS. For example, given a number of possi-\nble programs to run on a CPU, which program should the OS run? A\nscheduling policy in the OS will make this decision, likely using histori-\ncal information (e.g., which program has run more over the last min ute?),\nworkload knowledge (e.g., what types of programs are run), and per for-\nmance metrics (e.g., is the system optimizing for interactive performance,\nor throughput?"}
{"id": "9e51c67c-1cef-4df1-b3e1-43475dd15ca8", "file": "cpu-intro.pdf", "page": 2, "start": 1300, "end": 2100, "text": "owledge (e.g., what types of programs are run), and per for-\nmance metrics (e.g., is the system optimizing for interactive performance,\nor throughput?) to make its decision.\n4.1 The Abstraction: A Process\nThe abstraction provided by the OS of a running program is somethin g\nwe will call a process. As we said above, a process is simply a running\nprogram; at any instant in time, we can summarize a process by ta king an\ninventory of the different pieces of the system it accesses or aff ects during\nthe course of its execution.\nT o understand what constitutes a process, we thus have to under stand\nits machine state : what a program can read or update when it is running.\nAt any given time, what parts of the machine are important to the execu-\ntion of this program?\nOne obvious component of machin"}
{"id": "58333e99-d858-49e0-b155-54e9f7a913a7", "file": "cpu-intro.pdf", "page": 2, "start": 1950, "end": 2750, "text": "ate when it is running.\nAt any given time, what parts of the machine are important to the execu-\ntion of this program?\nOne obvious component of machine state that comprises a process is\nits memory. Instructions lie in memory; the data that the running pro-\ngram reads and writes sits in memory as well. Thus the memory tha t the\nprocess can address (called its address space ) is part of the process.\nAlso part of the process’s machine state are registers; many instructions\nexplicitly read or update registers and thus clearly they are important to\nthe execution of the process.\nNote that there are some particularly special registers that f orm part\nof this machine state. For example, the program counter (PC) (sometimes\ncalled the instruction pointer or IP) tells us which instruction of the pro-"}
{"id": "19dd6d1a-48d5-4020-82eb-2b9c4c570747", "file": "cpu-intro.pdf", "page": 2, "start": 2600, "end": 2893, "text": "t\nof this machine state. For example, the program counter (PC) (sometimes\ncalled the instruction pointer or IP) tells us which instruction of the pro-\ngram will execute next; similarly a stack pointer and associated frame\nOP E R AT I N G\nSY S T E M S\n[V E R S I O N 1.10]\nW W W.O S T E P.O R G"}
{"id": "aed3643a-d2bd-4ef9-9bc5-2e3845882d00", "file": "cpu-intro.pdf", "page": 3, "start": 0, "end": 800, "text": "TH E AB S T R A C T I O N : T H E PR O C E S S 3\nTI P : S E PA R AT E PO L I C Y AN D ME C H A N I S M\nIn many operating systems, a common design paradigm is to separa te\nhigh-level policies from their low-level mechanisms [L+75]. Y ou can\nthink of the mechanism as providing the answer to a how question about\na system; for example, how does an operating system perform a context\nswitch? The policy provides the answer to a which question; for example,\nwhich process should the operating system run right now? Separating the\ntwo allows one easily to change policies without having to rethin k the\nmechanism and is thus a form of modularity, a general software design\nprinciple.\npointer are used to manage the stack for function parameters, local vari -\nables, and return addresses.\nFinally , program"}
{"id": "9869c67e-e5ae-42d3-9d8c-a2f8d5d2f426", "file": "cpu-intro.pdf", "page": 3, "start": 650, "end": 1450, "text": "l software design\nprinciple.\npointer are used to manage the stack for function parameters, local vari -\nables, and return addresses.\nFinally , programs often access persistent storage devices too. Su ch I/O\ninformation might include a list of the ﬁles the process currently has open.\n4.2 Process API\nThough we defer discussion of a real process API until a subsequen t\nchapter , here we ﬁrst give some idea of what must be included in a ny\ninterface of an operating system. These APIs, in some form, are av ailable\non any modern operating system.\n• Create: An operating system must include some method to cre-\nate new processes. When you type a command into the shell, or\ndouble-click on an application icon, the OS is invoked to create a\nnew process to run the program you have indicated.\n• Destroy:"}
{"id": "aae82548-3be7-451a-b2a9-1298dfbb641a", "file": "cpu-intro.pdf", "page": 3, "start": 1300, "end": 2100, "text": "nd into the shell, or\ndouble-click on an application icon, the OS is invoked to create a\nnew process to run the program you have indicated.\n• Destroy: As there is an interface for process creation, systems also\nprovide an interface to destroy processes forcefully . Of course, many\nprocesses will run and just exit by themselves when complete; w hen\nthey don’t, however , the user may wish to kill them, and thus an in -\nterface to halt a runaway process is quite useful.\n• W ait: Sometimes it is useful to wait for a process to stop running;\nthus some kind of waiting interface is often provided.\n• Miscellaneous Control: Other than killing or waiting for a process,\nthere are sometimes other controls that are possible. For example,\nmost operating systems provide some kind of method to suspend a\np"}
{"id": "29e8da46-9f2b-451b-8940-d762281d40fc", "file": "cpu-intro.pdf", "page": 3, "start": 1950, "end": 2401, "text": "ng for a process,\nthere are sometimes other controls that are possible. For example,\nmost operating systems provide some kind of method to suspend a\nprocess (stop it from running for a while) and then resume it (con-\ntinue it running).\n• Status: There are usually interfaces to get some status information\nabout a process as well, such as how long it has run for , or what\nstate it is in.\n© 2008–23, A R PA C I-D U S S E A U TH R E E\nEA S Y\nPI E C E S"}
{"id": "0841283e-bcb5-4240-b5aa-6bf3c0e1513c", "file": "cpu-intro.pdf", "page": 4, "start": 0, "end": 800, "text": "4 T H E AB S T R A C T I O N : T H E PR O C E S S\nMemoryCPU\nDisk\ncode\nstatic data\nheap\nstack\nProcess\ncode\nstatic data\nProgram Loading:\nTakes on-disk program\nand reads it into the\naddress space of process\nFigure 4.1: Loading: From Program T o Process\n4.3 Process Creation: A Little More Detail\nOne mystery that we should unmask a bit is how programs are trans-\nformed into processes. Speciﬁcally , how does the OS get a program up\nand running? How does process creation actually work?\nThe ﬁrst thing that the OS must do to run a program is to load its code\nand any static data (e.g., initialized variables) into memor y , into the ad-\ndress space of the process. Programs initially reside on disk (or , in some\nmodern systems, ﬂash-based SSDs ) in some kind of executable format ;\nthus, the process of"}
{"id": "f8164cbd-dee0-4161-bd57-8e023608b802", "file": "cpu-intro.pdf", "page": 4, "start": 650, "end": 1395, "text": "he process. Programs initially reside on disk (or , in some\nmodern systems, ﬂash-based SSDs ) in some kind of executable format ;\nthus, the process of loading a program and static data into memory r e-\nquires the OS to read those bytes from disk and place them in memor y\nsomewhere (as shown in Figure 4.1).\nIn early (or simple) operating systems, the loading process is don e ea-\ngerly, i.e., all at once before running the program; modern OSes perform\nthe process lazily, i.e., by loading pieces of code or data only as they are\nneeded during program execution. T o truly understand how lazy l oading\nof pieces of code and data works, you’ll have to understand more about\nOP E R AT I N G\nSY S T E M S\n[V E R S I O N 1.10]\nW W W.O S T E P.O R G"}
{"id": "1959c4fc-a1e8-4364-b4f0-ef55ff6bea9d", "file": "cpu-intro.pdf", "page": 5, "start": 0, "end": 800, "text": "TH E AB S T R A C T I O N : T H E PR O C E S S 5\nthe machinery of paging and swapping, topics we’ll cover in the future\nwhen we discuss the virtualization of memory . For now , just rememb er\nthat before running anything, the OS clearly must do some work to get\nthe important program bits from disk into memory .\nOnce the code and static data are loaded into memory , there are a f ew\nother things the OS needs to do before running the process. Some mem -\nory must be allocated for the program’s run-time stack (or just stack).\nAs you should likely already know , C programs use the stack for local\nvariables, function parameters, and return addresses; the O S allocates\nthis memory and gives it to the process. The OS will also likely i nitial-\nize the stack with arguments; speciﬁcally , it will ﬁl"}
{"id": "d9a1d655-4245-4726-a470-69a379312abc", "file": "cpu-intro.pdf", "page": 5, "start": 650, "end": 1450, "text": "s; the O S allocates\nthis memory and gives it to the process. The OS will also likely i nitial-\nize the stack with arguments; speciﬁcally , it will ﬁll in the parameters to\nthe main() function, i.e., argc and the argv array .\nThe OS may also allocate some memory for the program’s heap. In C\nprograms, the heap is used for explicitly requested dynamical ly-allocated\ndata; programs request such space by calling malloc() and free it ex-\nplicitly by calling free(). The heap is needed for data structures such as\nlinked lists, hash tables, trees, and other interesting data structures. The\nheap will be small at ﬁrst; as the program runs, and requests mor e mem-\nory via the malloc() library API, the OS may get involved and allocate\nmore memory to the process to help satisfy such calls.\nThe OS will "}
{"id": "00285798-4c90-4118-9a9e-a69bf26a2311", "file": "cpu-intro.pdf", "page": 5, "start": 1300, "end": 2100, "text": " mor e mem-\nory via the malloc() library API, the OS may get involved and allocate\nmore memory to the process to help satisfy such calls.\nThe OS will also do some other initialization tasks, particular ly as re-\nlated to input/output (I/O). For example, in U N I X systems, each process\nby default has three open ﬁle descriptors , for standard input, output, and\nerror; these descriptors let programs easily read input from the terminal\nand print output to the screen. W e’ll learn more about I/O, ﬁle des crip-\ntors, and the like in the third part of the book on persistence.\nBy loading the code and static data into memory , by creating and i ni-\ntializing a stack, and by doing other work as related to I/O setup , the OS\nhas now (ﬁnally) set the stage for program execution. It thus has on e last"}
{"id": "4585751c-d6d6-42c6-b634-526cf25c3716", "file": "cpu-intro.pdf", "page": 5, "start": 1950, "end": 2750, "text": "ializing a stack, and by doing other work as related to I/O setup , the OS\nhas now (ﬁnally) set the stage for program execution. It thus has on e last\ntask: to start the program running at the entry point, namely main(). By\njumping to the main() routine (through a specialized mechanism that\nwe will discuss next chapter), the OS transfers control of the CP U to the\nnewly-created process, and thus the program begins its execut ion.\n4.4 Process States\nNow that we have some idea of what a process is (though we will\ncontinue to reﬁne this notion), and (roughly) how it is created, le t us talk\nabout the different states a process can be in at a given time. The notion\nthat a process can be in one of these states arose in early computer s ystems\n[DV66,V+65]. In a simpliﬁed view , a process can be "}
{"id": "29694c63-d19a-482a-a634-aa2e6762cb3f", "file": "cpu-intro.pdf", "page": 5, "start": 2600, "end": 3077, "text": "en time. The notion\nthat a process can be in one of these states arose in early computer s ystems\n[DV66,V+65]. In a simpliﬁed view , a process can be in one of three states:\n• Running: In the running state, a process is running on a processor .\nThis means it is executing instructions.\n• Ready: In the ready state, a process is ready to run but for some\nreason the OS has chosen not to run it at this given moment.\n© 2008–23, A R PA C I-D U S S E A U TH R E E\nEA S Y\nPI E C E S"}
{"id": "0b7d6d59-571c-4300-9189-89d802ddef3a", "file": "cpu-intro.pdf", "page": 6, "start": 0, "end": 800, "text": "6 T H E AB S T R A C T I O N : T H E PR O C E S S\nRunning Ready\nBlocked\nDescheduled\nScheduled\nI/O: initiate I/O: done\nFigure 4.2: Process: State T ransitions\n• Blocked: In the blocked state, a process has performed some kind\nof operation that makes it not ready to run until some other event\ntakes place. A common example: when a process initiates an I/O\nrequest to a disk, it becomes blocked and thus some other process\ncan use the processor .\nIf we were to map these states to a graph, we would arrive at the d i-\nagram in Figure 4.2. As you can see in the diagram, a process can b e\nmoved between the ready and running states at the discretion of t he OS.\nBeing moved from ready to running means the process has been sched-\nuled; being moved from running to ready means the process has been\ndesche"}
{"id": "f801eafb-922b-4dc3-bbd2-2e1703e1fc9a", "file": "cpu-intro.pdf", "page": 6, "start": 650, "end": 1450, "text": "t he OS.\nBeing moved from ready to running means the process has been sched-\nuled; being moved from running to ready means the process has been\ndescheduled. Once a process has become blocked (e.g., by initiating an\nI/O operation), the OS will keep it as such until some event occurs (e.g.,\nI/O completion); at that point, the process moves to the ready stat e again\n(and potentially immediately to running again, if the OS so de cides).\nLet’s look at an example of how two processes might transition through\nsome of these states. First, imagine two processes running, eac h of which\nonly use the CPU (they do no I/O). In this case, a trace of the stat e of each\nprocess might look like this (Figure 4.3).\nTime Process 0 Process1 Notes\n1 Running Ready\n2 Running Ready\n3 Running Ready\n4 Running Ready P"}
{"id": "530a4573-70c6-4eb0-b45b-803d8f61b4db", "file": "cpu-intro.pdf", "page": 6, "start": 1300, "end": 1651, "text": "t e of each\nprocess might look like this (Figure 4.3).\nTime Process 0 Process1 Notes\n1 Running Ready\n2 Running Ready\n3 Running Ready\n4 Running Ready Process 0 now done\n5 – Running\n6 – Running\n7 – Running\n8 – Running Process 1 now done\nFigure 4.3: T racing Process State: CPU Only\nOP E R AT I N G\nSY S T E M S\n[V E R S I O N 1.10]\nW W W.O S T E P.O R G"}
{"id": "2d2452cf-5f9e-49d2-b0e0-04c0e4810d56", "file": "cpu-intro.pdf", "page": 7, "start": 0, "end": 800, "text": "TH E AB S T R A C T I O N : T H E PR O C E S S 7\nTime Process 0 Process1 Notes\n1 Running Ready\n2 Running Ready\n3 Running Ready Process 0 initiates I/O\n4 Blocked Running Process 0 is blocked,\n5 Blocked Running so Process 1 runs\n6 Blocked Running\n7 Ready Running I/O done\n8 Ready Running Process 1 now done\n9 Running –\n10 Running – Process 0 now done\nFigure 4.4: T racing Process State: CPU and I/O\nIn this next example, the ﬁrst process issues an I/O after runn ing for\nsome time. At that point, the process is blocked, giving the other p rocess\na chance to run. Figure 4.4 shows a trace of this scenario.\nMore speciﬁcally , Process 0 initiates an I/O and becomes blocked wait-\ning for it to complete; processes become blocked, for example, when read-\ning from a disk or waiting for a packet from a ne"}
{"id": "0430d1f6-2c95-4a3f-9434-996b1ffde585", "file": "cpu-intro.pdf", "page": 7, "start": 650, "end": 1450, "text": " and becomes blocked wait-\ning for it to complete; processes become blocked, for example, when read-\ning from a disk or waiting for a packet from a network. The OS recog-\nnizes Process 0 is not using the CPU and starts running Process 1. While\nProcess1 is running, the I/O completes, moving Process 0 back to ready .\nFinally , Process1 ﬁnishes, and Process 0 runs and then is done.\nNote that there are many decisions the OS must make, even in this\nsimple example. First, the system had to decide to run Process 1 while\nProcess0 issued an I/O; doing so improves resource utilization by keep-\ning the CPU busy . Second, the system decided not to switch back to\nProcess0 when its I/O completed; it is not clear if this is a good deci-\nsion or not. What do you think? These types of decisions are made by"}
{"id": "11cf5825-8950-4cb1-84ff-b8614f6f26eb", "file": "cpu-intro.pdf", "page": 7, "start": 1300, "end": 2100, "text": " back to\nProcess0 when its I/O completed; it is not clear if this is a good deci-\nsion or not. What do you think? These types of decisions are made by th e\nOS scheduler, a topic we will discuss a few chapters in the future.\n4.5 Data Structures\nThe OS is a program, and like any program, it has some key data stru c-\ntures that track various relevant pieces of information. T o trac k the state\nof each process, for example, the OS likely will keep some kind of pro-\ncess list for all processes that are ready and some additional informa-\ntion to track which process is currently running. The OS must al so track,\nin some way , blocked processes; when an I/O event completes, the O S\nshould make sure to wake the correct process and ready it to run ag ain.\nFigure 4.5 shows what type of information an"}
{"id": "52c4ed67-2d8f-4c3d-9360-5c24b5dc0a63", "file": "cpu-intro.pdf", "page": 7, "start": 1950, "end": 2523, "text": " an I/O event completes, the O S\nshould make sure to wake the correct process and ready it to run ag ain.\nFigure 4.5 shows what type of information an OS needs to track about\neach process in the xv6 kernel [CK+08]. Similar process structu res exist\nin “real” operating systems such as Linux, Mac OS X, or Windows; l ook\nthem up and see how much more complex they are.\nFrom the ﬁgure, you can see a couple of important pieces of informa-\ntion the OS tracks about a process. The register context will hold, for a\n© 2008–23, A R PA C I-D U S S E A U TH R E E\nEA S Y\nPI E C E S"}
{"id": "746c157d-a703-435e-9729-6f763d980999", "file": "cpu-intro.pdf", "page": 8, "start": 0, "end": 800, "text": "8 T H E AB S T R A C T I O N : T H E PR O C E S S\n// the registers xv6 will save and restore\n// to stop and subsequently restart a process\nstruct context {\nint eip;\nint esp;\nint ebx;\nint ecx;\nint edx;\nint esi;\nint edi;\nint ebp;\n};\n// the different states a process can be in\nenum proc_state { UNUSED, EMBRYO, SLEEPING,\nRUNNABLE, RUNNING, ZOMBIE };\n// the information xv6 tracks about each process\n// including its register context and state\nstruct proc {\nchar *mem; // Start of process memory\nuint sz; // Size of process memory\nchar *kstack; // Bottom of kernel stack\n// for this process\nenum proc_state state; // Process state\nint pid; // Process ID\nstruct proc *parent; // Parent process\nvoid *chan; // If !zero, sleeping on chan\nint killed; // If !zero, has been killed\nstruct file *ofile[NOFILE];"}
{"id": "3dd9b708-ae3c-4b1f-a526-374b5c918a24", "file": "cpu-intro.pdf", "page": 8, "start": 650, "end": 1450, "text": "\nstruct proc *parent; // Parent process\nvoid *chan; // If !zero, sleeping on chan\nint killed; // If !zero, has been killed\nstruct file *ofile[NOFILE]; // Open files\nstruct inode *cwd; // Current directory\nstruct context context; // Switch here to run process\nstruct trapframe *tf; // Trap frame for the\n// current interrupt\n};\nFigure 4.5: The xv6 Proc Structure\nstopped process, the contents of its registers. When a process is s topped,\nits registers will be saved to this memory location; by restoring these reg-\nisters (i.e., placing their values back into the actual phys ical registers), the\nOS can resume running the process. W e’ll learn more about this tec hnique\nknown as a context switch in future chapters.\nY ou can also see from the ﬁgure that there are some other states a pr o-\ncess can"}
{"id": "2b27a2d6-0ada-4921-a932-d4c7dd9079a7", "file": "cpu-intro.pdf", "page": 8, "start": 1300, "end": 1734, "text": "about this tec hnique\nknown as a context switch in future chapters.\nY ou can also see from the ﬁgure that there are some other states a pr o-\ncess can be in, beyond running, ready , and blocked. Sometimes a sy stem\nwill have an initial state that the process is in when it is being created.\nAlso, a process could be placed in a ﬁnal state where it has exited but\nOP E R AT I N G\nSY S T E M S\n[V E R S I O N 1.10]\nW W W.O S T E P.O R G"}
{"id": "92466447-ed6a-4954-bdf0-9ffb7e55bcbe", "file": "cpu-intro.pdf", "page": 9, "start": 0, "end": 800, "text": "TH E AB S T R A C T I O N : T H E PR O C E S S 9\nAS I D E : D ATA ST R U C T U R E — T H E PR O C E S S LI S T\nOperating systems are replete with various important data structures\nthat we will discuss in these notes. The process list (also called the task\nlist) is the ﬁrst such structure. It is one of the simpler ones, but cer tainly\nany OS that has the ability to run multiple programs at once will have\nsomething akin to this structure in order to keep track of all the running\nprograms in the system. Sometimes people refer to the individual struc-\nture that stores information about a process as a Process Control Block\n(PCB), a fancy way of talking about a C structure that contains informa -\ntion about each process (also sometimes called a process descriptor ).\nhas not yet been cleaned up ("}
{"id": "3f463386-6b98-466a-adc0-087ad5b3cb60", "file": "cpu-intro.pdf", "page": 9, "start": 650, "end": 1450, "text": "lking about a C structure that contains informa -\ntion about each process (also sometimes called a process descriptor ).\nhas not yet been cleaned up (in UNIX-based systems, this is cal led the\nzombie state1 ). This ﬁnal state can be useful as it allows other processes\n(usually the parent that created the process) to examine the return code\nof the process and see if the just-ﬁnished process executed succ essfully\n(usually , programs return zero in U N I X-based systems when they have\naccomplished a task successfully , and non-zero otherwise). Wh en ﬁn-\nished, the parent will make one ﬁnal call (e.g., wait()) to wait for the\ncompletion of the child, and to also indicate to the OS that it can clean up\nany relevant data structures that referred to the now-extinc t process.\n4.6 Summary\nW e have"}
{"id": "2c6ba5ed-f20f-46cf-8d34-cdfa8dd80732", "file": "cpu-intro.pdf", "page": 9, "start": 1300, "end": 2100, "text": "hild, and to also indicate to the OS that it can clean up\nany relevant data structures that referred to the now-extinc t process.\n4.6 Summary\nW e have introduced the most basic abstraction of the OS: the process .\nIt is quite simply viewed as a running program. With this concep tual\nview in mind, we will now move on to the nitty-gritty: the low-leve l\nmechanisms needed to implement processes, and the higher-le vel poli-\ncies required to schedule them in an intelligent way . By combi ning mech-\nanisms and policies, we will build up our understanding of how an op er-\nating system virtualizes the CPU.\n1 Y es, the zombie state. Just like real zombies, these zombies are relatively easy to kill.\nHowever , different techniques are usually recommended.\n© 2008–23, A R PA C I-D U S S E A U TH R E E\n"}
{"id": "93f8d093-87e2-4b70-9b5e-497b5baf12ee", "file": "cpu-intro.pdf", "page": 9, "start": 1950, "end": 2117, "text": "bies, these zombies are relatively easy to kill.\nHowever , different techniques are usually recommended.\n© 2008–23, A R PA C I-D U S S E A U TH R E E\nEA S Y\nPI E C E S"}
{"id": "9b73ebdf-10e9-42ad-a785-e2a7f28c3fd9", "file": "cpu-intro.pdf", "page": 10, "start": 0, "end": 800, "text": "10 T H E AB S T R A C T I O N : T H E PR O C E S S\nAS I D E : K E Y PR O C E S S TE R M S\n• The process is the major OS abstraction of a running program. At\nany point in time, the process can be described by its state: the con-\ntents of memory in its address space , the contents of CPU registers\n(including the program counter and stack pointer , among others),\nand information about I/O (such as open ﬁles which can be read or\nwritten).\n• The process API consists of calls programs can make related to pro-\ncesses. T ypically , this includes creation, destruction, and other use-\nful calls.\n• Processes exist in one of many different process states , including\nrunning, ready to run, and blocked. Different events (e.g., g etting\nscheduled or descheduled, or waiting for an I/O to complete) tran -\n"}
{"id": "96235305-793d-43cb-bd58-a1cada6f6f14", "file": "cpu-intro.pdf", "page": 10, "start": 650, "end": 1166, "text": " , including\nrunning, ready to run, and blocked. Different events (e.g., g etting\nscheduled or descheduled, or waiting for an I/O to complete) tran -\nsition a process from one of these states to the other .\n• A process list contains information about all processes in the sys-\ntem. Each entry is found in what is sometimes called a process\ncontrol block (PCB), which is really just a structure that contains\ninformation about a speciﬁc process.\nOP E R AT I N G\nSY S T E M S\n[V E R S I O N 1.10]\nW W W.O S T E P.O R G"}
{"id": "95d6c288-9396-408f-b361-244f46a4d400", "file": "cpu-intro.pdf", "page": 11, "start": 0, "end": 800, "text": "TH E AB S T R A C T I O N : T H E PR O C E S S 11\nReferences\n[BH70] “The Nucleus of a Multiprogramming System” by Per Brinch Hansen. C ommunica-\ntions of the ACM, V olume 13:4, April 1970. This paper introduces one of the ﬁrst microkernels in\noperating systems history, called Nucleus. The idea of smaller , more mi nimal systems is a theme that\nrears its head repeatedly in OS history; it all began with Brinch Hansen’s work described herein.\n[CK+08] “The xv6 Operating System” by Russ Cox, Frans Kaashoek, Robe rt Morris, Nickolai\nZeldovich. From: https://github.com/mit-pdos/xv6-public. The coolest real and little OS in the\nworld. Download and play with it to learn more about the details of how operating syste ms actually\nwork. We have been using an older version (2012-01-30-1-g1c41342) and he"}
{"id": "6eb88b66-9902-441a-90ee-354a8e91f7cc", "file": "cpu-intro.pdf", "page": 11, "start": 650, "end": 1450, "text": "ay with it to learn more about the details of how operating syste ms actually\nwork. We have been using an older version (2012-01-30-1-g1c41342) and hen ce some examples in the\nbook may not match the latest in the source.\n[DV66] “Programming Semantics for Multiprogrammed Computations” b y Jack B. Dennis,\nEarl C. V an Horn. Communications of the ACM, V olume 9, Number 3, March 1 966 . This paper\ndeﬁned many of the early terms and concepts around building multiprogramme d systems.\n[L+75] “Policy/mechanism separation in Hydra” by R. Levin, E. Cohen, W . Corwin, F . Pollack,\nW . Wulf. SOSP ’75, Austin, T exas, November 1975. An early paper about how to structure operat-\ning systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of\nits ideas inﬂuenced OS designer"}
{"id": "fdd57aac-2688-4d3f-b828-8ae7f87708db", "file": "cpu-intro.pdf", "page": 11, "start": 1300, "end": 1860, "text": "ow to structure operat-\ning systems in a research OS known as Hydra. While Hydra never became a mainstream OS, some of\nits ideas inﬂuenced OS designers.\n[V+65] “Structure of the Multics Supervisor ” by V .A. V yssotsky , F . J. Corbato, R. M. Graham.\nFall Joint Computer Conference, 1965. An early paper on Multics, which described many of the basic\nideas and terms that we ﬁnd in modern systems. Some of the vision behind comp uting as a utility are\nﬁnally being realized in modern cloud systems.\n© 2008–23, A R PA C I-D U S S E A U TH R E E\nEA S Y\nPI E C E S"}
{"id": "84cf165f-59f8-4100-81bb-53d998b58163", "file": "cpu-intro.pdf", "page": 12, "start": 0, "end": 800, "text": "12 T H E AB S T R A C T I O N : T H E PR O C E S S\nHomework (Simulation)\nThis program, process-run.py, allows you to see how process states\nchange as programs run and either use the CPU (e.g., perform an a dd\ninstruction) or do I/O (e.g., send a request to a disk and wait for it to\ncomplete). See the README for details.\nQuestions\n1. Run process-run.py with the following ﬂags: -l 5:100,5:100.\nWhat should the CPU utilization be (e.g., the percent of time the\nCPU is in use?) Why do you know this? Use the -c and -p ﬂags to\nsee if you were right.\n2. Now run with these ﬂags: ./process-run.py -l 4:100,1:0.\nThese ﬂags specify one process with 4 instructions (all to use th e\nCPU), and one that simply issues an I/O and waits for it to be done.\nHow long does it take to complete both processes? Use -c"}
{"id": "72cd41c0-aaa3-402c-b3e8-11285858b4cf", "file": "cpu-intro.pdf", "page": 12, "start": 650, "end": 1450, "text": "uctions (all to use th e\nCPU), and one that simply issues an I/O and waits for it to be done.\nHow long does it take to complete both processes? Use -c and -p\nto ﬁnd out if you were right.\n3. Switch the order of the processes: -l 1:0,4:100. What happens\nnow? Does switching the order matter? Why? (As always, use -c\nand -p to see if you were right)\n4. W e’ll now explore some of the other ﬂags. One important ﬂag is\n-S, which determines how the system reacts when a process is-\nsues an I/O. With the ﬂag set to SWITCH\nON END, the system\nwill NOT switch to another process while one is doing I/O, in-\nstead waiting until the process is completely ﬁnished. What ha p-\npens when you run the following two processes ( -l 1:0,4:100\n-c -S SWITCH\nON END), one doing I/O and the other doing CPU\nwork?\n5. Now ,"}
{"id": "b4585078-41e7-45dc-95f6-2c77bec7efca", "file": "cpu-intro.pdf", "page": 12, "start": 1300, "end": 2100, "text": "ed. What ha p-\npens when you run the following two processes ( -l 1:0,4:100\n-c -S SWITCH\nON END), one doing I/O and the other doing CPU\nwork?\n5. Now , run the same processes, but with the switching behavior s et\nto switch to another process whenever one is W AITING for I/O ( -l\n1:0,4:100 -c -S SWITCH ON IO). What happens now? Use -c\nand -p to conﬁrm that you are right.\n6. One other important behavior is what to do when an I/O com-\npletes. With -I IO RUN LATER, when an I/O completes, the pro-\ncess that issued it is not necessarily run right away; rather , what-\never was running at the time keeps running. What happens when\nyou run this combination of processes? ( ./process-run.py -l\n3:0,5:100,5:100,5:100 -S SWITCH\nON IO -c -p -I\nIO RUN LATER) Are system resources being effectively utilized?\n"}
{"id": "3f5465d8-7d87-4bdd-9e1e-e449dd47e158", "file": "cpu-intro.pdf", "page": 12, "start": 1950, "end": 2402, "text": "ion of processes? ( ./process-run.py -l\n3:0,5:100,5:100,5:100 -S SWITCH\nON IO -c -p -I\nIO RUN LATER) Are system resources being effectively utilized?\n7. Now run the same processes, but with -I IO RUN IMMEDIATE set,\nwhich immediately runs the process that issued the I/O. How does\nthis behavior differ? Why might running a process that just com-\npleted an I/O again be a good idea?\nOP E R AT I N G\nSY S T E M S\n[V E R S I O N 1.10]\nW W W.O S T E P.O R G"}
{"id": "06a1b65c-4fe1-4ec8-9091-1986553c21d3", "file": "cpu-intro.pdf", "page": 13, "start": 0, "end": 451, "text": "TH E AB S T R A C T I O N : T H E PR O C E S S 13\n8. Now run with some randomly generated processes using ﬂags -s\n1 -l 3:50,3:50 or -s 2 -l 3:50,3:50 or -s 3 -l 3:50,\n3:50. See if you can predict how the trace will turn out. What hap-\npens when you use the ﬂag -I IO RUN IMMEDIATE versus that\nﬂag -I IO RUN LATER? What happens when you use the ﬂag -S\nSWITCH ON IO versus -S SWITCH ON END?\n© 2008–23, A R PA C I-D U S S E A U TH R E E\nEA S Y\nPI E C E S"}
{"id": "2c73879f-a7aa-4a37-9ade-5d622718da28", "file": "Ordinance No. 1034.pdf", "page": 1, "start": 0, "end": 800, "text": "ORDINANCE NO. 1034\n \nAN ORDINANCE OF THE CITY COUNCIL OF THE CITY OF \nLANCASTER, CALIFORNIA, AMENDING TITLE 15 OF THE \nLANCASTER MUNICIPAL CODE BY ADDING CHAPTER \n15.46 (ELECTRIC VEHICLE CHARGING SYSTEMS), \nESTABLISHING PROCEDURES FOR AN EXPEDITED, \nSTREAMLINED PERMITTING PROCESS FOR ELECTRIC \nVEHICLE CHARGING STATIONS AS REQUIRED BY \nGOVERNMENT CODE SECTION 65850.7\n \nWHEREAS, the State of California and the City of Lancaster have consistently promoted \nand encouraged the use of fuel-efficient electric vehicles; and\n \nWHEREAS, in 2015, the State of California enacted Assembly Bill 1236 (codified at \nGovernment Code Section 65850.7), which requires local agencies to adopt an ordinance that \ncreates an expedited, streamlined permitting process for electric vehicle charging systems; and\n \nWHE"}
{"id": "a3812d9f-4d01-4bd7-a34b-b76e8ebbf729", "file": "Ordinance No. 1034.pdf", "page": 1, "start": 650, "end": 1450, "text": "uires local agencies to adopt an ordinance that \ncreates an expedited, streamlined permitting process for electric vehicle charging systems; and\n \nWHEREAS, creation of an expedited, streamlined permitting process for electric vehicle \ncharging stations would facilitate convenient charging of electric vehicles and help reduce the \nCity’s reliance on environmentally damaging fossil fuels.\n \nNOW THEREFORE, THE CITY COUNCIL OF THE CITY OF LANCASTER \nCALIFORNIA DOES HEREBY ORDAIN, AS FOLLOWS:\n \nSection 1. Chapter 15.46, Electric Vehicle Charging Stations, is hereby added to Title\n15 of the Lancaster Municipal Code, as follows:\n \n15.46.010 Title and Purpose\n \nThe purpose of this Chapter is to promote and encourage the use of electric vehicles, in \naccordance with California Government Code Secti"}
{"id": "43751271-87e3-46d7-bf18-ddfd7ee91b99", "file": "Ordinance No. 1034.pdf", "page": 1, "start": 1300, "end": 2100, "text": "d Purpose\n \nThe purpose of this Chapter is to promote and encourage the use of electric vehicles, in \naccordance with California Government Code Section 65850.7, by creating an expedited, \nstreamlined permitting process for electric vehicle charging stations, while promoting \npublic health and safety and preventing specific adverse impacts in the installation and use \nof such charging stations.\n \n15.46.020 Definitions\n \na) “Electric vehicle charging station” or “charging station” means any level of electric vehicle supply equipment station that is designed and built in compliance with Article 625 of the California Electrical Code, as it reads on the effective date of this Chapter, and delivers electricity from a source outside an electric vehicle into a plug-in electric vehicle. b) “Specif"}
{"id": "6c2713d1-0c48-4ebd-b120-5d06d87d3dbc", "file": "Ordinance No. 1034.pdf", "page": 1, "start": 1950, "end": 2354, "text": " on the effective date of this Chapter, and delivers electricity from a source outside an electric vehicle into a plug-in electric vehicle. b) “Specific, adverse impact” means a significant, quantifiable, direct, and unavoidable impact, based on objective, identified, and written public health or safety standards, policies, or conditions as they existed on the date the application was deemed complete."}
{"id": "a7513ee0-baed-4309-86a4-4f8ba8a7900b", "file": "Ordinance No. 1034.pdf", "page": 2, "start": 0, "end": 800, "text": "Ordinance No. 1034 \nPage 2\n \n(c) “Electronic submittal” means the utilization of one or more of the following:1. Electronic mail or email. The internet.3. Facsimile. 15.46.030 Duties of the Building Official Consistent with Government Code Section 65850.7, the Building Official shall: a) Implement an expedited, streamlined permitting process for electric vehicle charging stations; b) Adopt a checklist of all requirements with which electric vehicle charging stations shall comply with in order to be eligible for expedited review, which shall be based on the “Plug-In Electric Vehicle Infrastructure Permitting Checklist” of the “Zero-Emission Vehicles in California: Community Readiness Guidebook” of the Governor’s Office of Planning and Research; c) Ensure that the expedited, streamlined perm"}
{"id": "b07cb687-bd26-4bd5-991a-f577e2bebe21", "file": "Ordinance No. 1034.pdf", "page": 2, "start": 650, "end": 1450, "text": "hicles in California: Community Readiness Guidebook” of the Governor’s Office of Planning and Research; c) Ensure that the expedited, streamlined permitting process and checklist shall be published on the City’s website. 15.46.040 Permit Review and Inspection Requirements a) Prior to submitting an application for processing, the applicant shall verify that the installation of an electric vehicle charging station will not have specific, adverseimpacts to public health and safety and building occupants.Verification by theapplicant includes but is not limited to: electrical system capacity and loads; electrical system wiring, bonding and overcurrent protection; building infrastructure affected by charging station equipment and associated conduits; areas of charging station equipment and vehic"}
{"id": "c8a33cc6-b2b2-4559-9bd1-df1c7cefe354", "file": "Ordinance No. 1034.pdf", "page": 2, "start": 1300, "end": 2100, "text": "rent protection; building infrastructure affected by charging station equipment and associated conduits; areas of charging station equipment and vehicle parking. Upon filing the application, the applicant shall pay a permit application fee as established by resolution adopted by the City Council as amended from time to time. b) A permit application that satisfies the information requirements in the City’s adopted checklist shall be deemed complete and be promptly processed. Upon confirmation by the Building Official that the permit application and supporting documents meet the requirements of the City adopted checklist, and is consistent with all applicable laws and health and safety standards, the Building Official shall, consistent with Government Code Section 65850.7, approve the applic"}
{"id": "f1ccf3f4-ce4c-4f1b-8981-1aeec6aa5ac2", "file": "Ordinance No. 1034.pdf", "page": 2, "start": 1950, "end": 2625, "text": " all applicable laws and health and safety standards, the Building Official shall, consistent with Government Code Section 65850.7, approve the application and issue all necessary permits. Such approval does not authorize an applicant to energize or utilize the electric vehicle charging station until final inspection and approval of the installation of the station has been granted by the City. If the Building Official determines that the permit application is incomplete, he or she shall issue a written correction notice to the applicant, detailing all deficiencies in the application and any additional information required to be eligible for expedited permit issuance."}
{"id": "3c50520e-241f-4c99-9668-e67bbcbd7163", "file": "Ordinance No. 1034.pdf", "page": 3, "start": 0, "end": 800, "text": "Ordinance No. 1034 \nPage 3\n \nc) If the Building Official makes a finding based on substantial evidence that the electric \nvehicle charging station could have a specific adverse impact upon the public health or \nsafety, as defined in this Chapter, the City may require the applicant to apply for a use \npermit.\n \nd) Consistent with Government Code Section 65850.7, the Building Official shall allow\nfor electronic submittal of permit applications covered by this Ordinance and associated\nsupporting documentations. In accepting such permit applications, the Building\nOfficial shall also accept electronic signatures on all forms, applications, and other\ndocumentation in lieu of a wet signature by any applicant.\n \n15.46.050. Electric Vehicle Charging Station Installation Requirements. a) Electric ve"}
{"id": "055833ab-5443-4022-905b-9f780666db59", "file": "Ordinance No. 1034.pdf", "page": 3, "start": 650, "end": 1450, "text": "er\ndocumentation in lieu of a wet signature by any applicant.\n \n15.46.050. Electric Vehicle Charging Station Installation Requirements. a) Electric vehicle charging station equipment shall meet the requirements of the California Electrical Code, the Society of Automotive Engineers, the National Electrical Manufacturers Association, and accredited testing laboratories, such as Underwriters Laboratories, and rules of the Public Utilities Commission or a Municipal Electric Utility Company regarding safety and reliability. b) Installation of electric vehicle charging stations and associated wiring, bonding, disconnecting means and overcurrent protective devices shall meet the requirements of Article 625 and all applicable provisions of the California Electrical Code. c) Installation of electri"}
{"id": "a5170bd2-096b-4fd7-bfb4-0cb0bc0ecf9c", "file": "Ordinance No. 1034.pdf", "page": 3, "start": 1300, "end": 2100, "text": "tective devices shall meet the requirements of Article 625 and all applicable provisions of the California Electrical Code. c) Installation of electric vehicle charging stations shall be incorporated into the load calculations of all new or existing electrical services and shall meet the requirementsof the California Electrical Code. Electric vehicle charging equipment shall beconsidered a continuous load. d) Anchorage of either floor-mounted or wall-mounted electric vehicle charging stations shall meet the requirements of the California Building or Residential Code as applicable per occupancy, and the provisions of the manufacturer’s installationinstructions.Mounting of charging stations shall not adversely affect buildingelements. Section2.Constitutionality. If any section, subsection, s"}
{"id": "d64280b2-04e4-459e-b6eb-caf8b6c4c5ba", "file": "Ordinance No. 1034.pdf", "page": 3, "start": 1950, "end": 2698, "text": "ationinstructions.Mounting of charging stations shall not adversely affect buildingelements. Section2.Constitutionality. If any section, subsection, sentence, clause or phrase ofthis ordinance is, for any reason, held to be unconstitutional, such decision shall not affect thevalidity of the remaining portions of this ordinance. The City Council hereby declares that it would have adopted this ordinance, and each section, subsection, clause or phrase thereof, irrespective of the fact that any one (1) or more sections, subsections, sentences, clauses and phrases be declared unconstitutional. Section 3. That the City Clerk shall certify to the passage of this Ordinance and willsee that it is published and posted in the manner required by law."}
{"id": "00fae526-de2e-435e-8dad-48311a5e1a25", "file": "Ordinance No. 1034.pdf", "page": 4, "start": 0, "end": 800, "text": "Ordinance No. 1034 \nPage 4\n \nI, Britt Avrit, MMC, City Clerk of the City of Lancaster, do hereby certify that the foregoing \nordinance was regularly introduced and placed upon its first reading on the 26th day of September, \n2017 and placed upon its second reading and adoption at a regular meeting of the City Council on \nthe 10th day of October, 2017, by the following vote:\n \nAYES:\n \n \nNOES:\n \nABSTAIN:\n \nABSENT:\n \n \nATTEST: APPROVED:\n \n \n \n____________________________ ______________________________\nBRITT AVRIT, MMC R. REX PARRIS\nCity Clerk Mayor \nCity of Lancaster City of Lancaster\n \n \n \nSTATE OF CALIFORNIA }\nCOUNTY OF LOS ANGELES }ss\nCITY OF LANCASTER }\n \n \nCERTIFICATION OF ORDINANCE \nCITY COUNCIL\n \nI, ________________________________, ___________________________________ City of\nLancaster"}
{"id": "89d7f9b9-f8ed-447d-9adf-50eb139fc4a9", "file": "Ordinance No. 1034.pdf", "page": 4, "start": 650, "end": 1111, "text": " LANCASTER }\n \n \nCERTIFICATION OF ORDINANCE \nCITY COUNCIL\n \nI, ________________________________, ___________________________________ City of\nLancaster, California, do hereby certify that this is a true and correct copy of the original Ordinance\nNo. 1034, for which the original is on file in my office.\n \nWITNESS MY HAND AND THE SEAL OF THE CITY OF LANCASTER, on this _________\nday of ________________, ________.\n \n(seal)\n \n \n___________________________________"}
